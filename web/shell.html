<!doctype html>
<html lang="en-us">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>AB Engine</title>
  </head>
  <body>
    <div
      style="width: 100vw; height: 100vh; display: flex; flex-direction: column"
    >
      <div id="canvas-parent" style="flex: 1; overflow: hidden">
        <canvas
          id="canvas"
          oncontextmenu="event.preventDefault()"
          tabindex="-1"
        ></canvas>
      </div>

      <div
        draggable="false"
        id="terminal"
        style="display: flex; flex-direction: column; height: 0"
      >
        <div
          style="
            height: 1px;
            width: 100vw;
            background-color: #2b2b2b;
            position: relative;
          "
        >
          <div id="terminal-top-bar"></div>
        </div>
        <div id="controls" style="background-color: #121212; display: flex">
          <button onclick="clearOutput()">Clear</button>
          <button onclick="scrollToBottom()">Jump to bottom</button>
        </div>
        <div
          class="scrollbar-black"
          id="output"
          style="
            padding: 15px;
            flex: 1;
            overflow-y: scroll;
            background-color: #121212;
            color: #e1e1e1;
          "
        ></div>
      </div>
    </div>

    <script type="text/javascript">
      var canvasElement = document.getElementById("canvas");
      var canvasParentElement = document.getElementById("canvas-parent");
      const ctx = canvasElement.getContext("2d");

      const minTerminalHeight = 100;
      const minCanvasHeight = 100;
      var terminalElement = document.getElementById("terminal");
      var terminalTopBar = document.getElementById("terminal-top-bar");
      var outputElement = document.getElementById("output");
      var controlsElement = document.getElementById("controls");

      const numBlocks = 50;
      const blockSize = 50;
      let blocks = [];
      function addBlock() {
        const textNode = document.createTextNode("");
        outputElement.appendChild(textNode);
        blocks.push(textNode);
        while (blocks.length > numBlocks) {
          const oldest = blocks.shift();
          outputElement.removeChild(oldest);
        }
        currentBlock = blocks.length - 1;
        currentLine = 0;
      }

      let followOutput = true;
      let currentBlock = 0;
      let currentLine = 0;
      addBlock();
      function outputText(text) {
        let targetNode = blocks[currentBlock];
        targetNode.data += text + "\n";
        currentLine++;
        if (currentLine > blockSize) addBlock();
        if (followOutput) scrollToBottom();
      }
      function clearOutput() {
        let currentBlock = 0;
        let currentLine = 0;
        outputElement.replaceChildren();
        blocks = [];
        addBlock();
      }

      scrollToBottom();
      function scrollToBottom() {
        outputElement.scrollTop = outputElement.scrollHeight;
      }

      var Module = {
        print(...args) {
          outputText(args.join(" "));
        },
        printErr(...args) {
          outputText(args.join(" "))
        },
        locateFile(path) {
          if (path.endsWith(".wasm")) {
            return path + "?v=" + Date.now();
          }
          return path;
        },
        canvas: canvasElement,
        totalDependencies: 0,
      };

      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function resizeCanvas() {
        const rect = canvasParentElement.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        canvasElement.style.width = `${rect.width}px`;
        canvasElement.style.height = `${rect.height}px`;

        const bufferWidth = Math.round(rect.width * dpr);
        const bufferHeight = Math.round(rect.height * dpr);

        if (
          canvasElement.width !== bufferWidth ||
          canvasElement.height !== bufferHeight
        ) {
          canvasElement.width = bufferWidth;
          canvasElement.height = bufferHeight;
        }

        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

        return { width: rect.width, height: rect.height, dpr };
      }

      let terminalHeight =
        parseInt(localStorage.getItem("terminalHeight")) ?? minTerminalHeight;
      setTerminalHeight(terminalHeight);

      let terminalOpen = localStorage.getItem("terminalOpen")
        ? localStorage.getItem("terminalOpen") == "true"
        : true;
      setTerminalOpen(terminalOpen);

      function setTerminalOpen(open) {
        terminalOpen = open;
        if (terminalOpen) {
          terminalElement.style.display = "flex";
          localStorage.setItem("terminalOpen", "true");
        } else {
          terminalElement.style.display = "none";
          localStorage.setItem("terminalOpen", "false");
        }
        resizeCanvas();
      }

      function setTerminalGrabbed(grabbed) {
        grabbedTerminal = grabbed;
        if (grabbed) {
          document.body.style.cursor = "n-resize";
          terminalTopBar.classList.add("terminal-grabbed");
          outputElement.classList.add("no-select");
          controlsElement.classList.add("no-select");
        } else {
          document.body.style.cursor = "auto";
          terminalTopBar.classList.remove("terminal-grabbed");
          outputElement.classList.remove("no-select");
          controlsElement.classList.remove("no-select");
        }
        if (isNaN(terminalHeight)) {
          localStorage.setItem("terminalHeight", minTerminalHeight);
        } else {
          localStorage.setItem("terminalHeight", terminalHeight);
        }
      }

      function setTerminalHeight(height) {
        if (isNaN(height)) height = minTerminalHeight;
        canvasHeight = window.innerHeight - height;
        if (height <= minTerminalHeight) height = minTerminalHeight;
        if (canvasHeight <= minCanvasHeight)
          height = window.innerHeight - minCanvasHeight;
        terminalElement.style.height = `${height}px`;
        resizeCanvas();
        if (followOutput) scrollToBottom();
      }

      let mouseY = 0;
      let grabbedTerminal = false;
      terminalTopBar.addEventListener("mousedown", () => {
        setTerminalGrabbed(true);
      });

      window.addEventListener("mouseup", () => {
        setTerminalGrabbed(false);
      });
      window.addEventListener("mousemove", (e) => {
        mouseY = e.clientY;
        if (grabbedTerminal) {
          terminalHeight = window.innerHeight - mouseY;
          setTerminalHeight(terminalHeight);
        }
      });

      outputElement.addEventListener("scroll", (e) => {
        const height = outputElement.scrollHeight;
        const scroll = outputElement.scrollTop + outputElement.clientHeight;

        const epsilon = 20;
        if (scroll + epsilon > height) followOutput = true;
        else followOutput = false;
      });

      let controlIsHeld = false;
      window.addEventListener("keydown", (e) => {
        if (e.key == "Control") controlIsHeld = true;
        if (e.key == "`" && controlIsHeld) {
          event.preventDefault();
          setTerminalOpen(!terminalOpen);
        }
      });
      window.addEventListener("keyup", (e) => {
        if (e.key == "Control") controlIsHeld = false;
      });
      window.addEventListener("blur", () => {
        controlIsHeld = false;
        setTerminalGrabbed(false);
      });
    </script>
    {{{ SCRIPT }}}
    <style>
      * {
        margin: 0;
        padding: 0;
        border: 0;
        font-family: Monospace, Courier, sans-serif;
      }
      html body {
        height: 100%;
        color: white;
        background-color: black;
      }
      li {
        list-style: none;
        font-size: 12px;
        margin: 5px 0;
      }
      button {
        padding: 5px 10px;
        background-color: #00000000;
        color: #aaa;
      }
      button:hover {
        color: #d0d0d0;
        cursor: pointer;
      }

      .no-select {
        user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
      }

      .scrollbar-black::-webkit-scrollbar-track {
        background-color: #121212;
      }
      .scrollbar-black {
        scrollbar-color: #666 #121212;
        scrollbar-width: auto;
      }

      .scrollbar-black::-webit-scrollbar {
        width: 12px;
      }

      .scrollbar-black::-webkit-scrollbar-track {
        background: #121212;
      }

      .scrollbar-black::-webkit-scrollbar-thumb {
        background: #666;
      }

      #output {
        white-space: pre-wrap;
        line-height: 1.5;
        font-size: 14px;
      }

      @keyframes fadeIn {
        to {
          opacity: 1;
        }
      }
      @keyframes fadeOut {
        to {
          opacity: 0;
        }
      }
      #terminal-top-bar {
        background-color: rgb(0, 170, 255);
        position: absolute;
        height: 4px;
        bottom: 0;
        width: 100%;
        opacity: 0;
      }
      #terminal-top-bar:hover {
        animation-name: fadeIn;
        animation-delay: 0.25s;
        animation-duration: 0.25s;
        animation-fill-mode: both;
        cursor: n-resize;
      }
      #terminal-top-bar.terminal-grabbed {
        opacity: 1;
        animation-name: fadeIn;
        animation-duration: 0.25s;
        animation-fill-mode: both;
      }
    </style>
  </body>
</html>
